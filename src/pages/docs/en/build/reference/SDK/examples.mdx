---
title: Examples
position: 3
layout: "@docs"
---

On this page you will find some more complex examples of using the Deta SDK.

/_ Python _/

## Base

### Put

```py
from deta import Deta
deta = Deta("project key")
db = deta.Base("simple_db")

# store objects
# a key will be automatically generated
db.put({"name": "alex", "age": 77})
# we will use "one" as a key
db.put({"name": "alex", "age": 77}, "one")
# the key could also be included in the object itself
db.put({"name": "alex", "age": 77, "key": "one"})

# simple types
db.put("hello, worlds")
db.put(7)
# "success" is the value and "smart_work" is the key.
db.put("success", "smart_work")
db.put(["a", "b", "c"], "my_abc")

# expiring items
# expire item in 300 seconds
db.put({"name": "alex", "age": 23}, "alex23", expire_in=300)
# expire item at date
expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
db.put({"name": "max", "age": 28}, "max28", expire_at=expire_at)
```

### Insert

```py
# will succeed, a key will be auto-generated
db.insert("hello, world")

# will succeed.
db.insert({"message": "hello, world"}, "greeting1")

# will raise an error as key "greeting1" already existed.
db.insert({"message": "hello, there"}, "greeting1")

# expiring items
# expire in 300 seconds
db.insert({"message": "will be deleted"}, "temp_greeting", expire_in=300)

# expire at date
expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
db.insert({"message": "will_be_deleted"}, "temp_greeting2", expire_at=expire_at)
```

### Put Many

```py
db.put_many([
    {"name": "Beverly", "hometown": "Copernicus City", "key": "one"}, // key provided
    "dude", // key auto-generated
    ["Namask훮ra", "marhabaan", "hello", "yeoboseyo"] // key auto-generated
])

# put many to expire in 300 seconds
db.put_many(
    [{"key": "tmp-1", "value": "test-1"}, {"key": "tmp-2", "value": "test-2"}],
    expire_in=300,
)

# put many with expire at
expire_at = datetime.datetime.fromisoformat("2023-01-01T00:00:00")
db.put_many(
    [{"key": "tmp-1", "value": "test-1"}, {"key": "tmp-2", "value": "test-2"}],
    expire_at=expire_at,
)
```

Output example:

```json
{
  "processed": {
    "items": [
      {
        "hometown": "Copernicus City",
        "key": "one",
        "name": "Beverly"
      },
      {
        "key": "jyesxxlrezo0",
        "value": "dude"
      },
      {
        "key": "5feqybn7lb05",
        "value": ["Namask훮ra", "hello", "marhabaan", "yeoboseyo"]
      }
    ]
  }
}
```

### Update

Consider we have the following item in a base:

```json
{
  "key": "user-a",
  "username": "jimmy",
  "profile": {
    "age": 32,
    "active": false,
    "hometown": "pittsburgh"
  },
  "on_mobile": true,
  "likes": ["anime"],
  "purchases": 1
}
```

Then the following update operation:

```py
updates = {
    "profile.age": 33,  # set profile.age to 33
    "profile.active": True, # set profile.active to true
    "profile.email": "jimmy@deta.sh", # create a new attribute 'profile.email'
    "profile.hometown": users.util.trim(), # remove 'profile.hometown'
    "on_mobile": users.util.trim(), # remove 'on_mobile'
    "purchases": users.util.increment(2), # increment by 2, default value is 1
    "likes": users.util.append("ramen") # append 'ramen' to 'likes', also accepts a list
}

db.update(updates, "user-a")
```

Results in the following item in the base:

```json
{
  "key": "user-a",
  "username": "jimmy",
  "profile": {
    "age": 33,
    "active": true,
    "email": "jimmy@deta.sh"
  },
  "likes": ["anime", "ramen"],
  "purchases": 3
}
```

### Fetch

For the examples, let's assume we have a **Base** with the following data:

```json
[
  {
    "key": "key-1",
    "name": "Wesley",
    "age": 27,
    "hometown": "San Francisco"
  },
  {
    "key": "key-2",
    "name": "Beverly",
    "age": 51,
    "hometown": "Copernicus City"
  },
  {
    "key": "key-3",
    "name": "Kevin Garnett",
    "age": 43,
    "hometown": "Greenville"
  }
]
```

```py
first_fetch_res = db.fetch({"age?lt": 30})
second_fetch_res = db.fetch([{"age?gt": 50}, {"hometown": "Greenville"}])
```

... will come back with following data:

`first_fetch_res.items`:

```json
[
  {
    "key": "key-1",
    "name": "Wesley",
    "age": 27,
    "hometown": "San Francisco"
  }
]
```

`second_fetch_res.items`:

```json
[
  {
    "key": "key-2",
    "name": "Beverly",
    "age": 51,
    "hometown": "Copernicus City"
  },
  {
    "key": "key-3",
    "name": "Kevin Garnett",
    "age": 43,
    "hometown": "Greenville"
  }
]
```

#### Fetch All Items

```py
res = db.fetch()
all_items = res.items

# fetch until last is 'None'
while res.last:
    res = db.fetch(last=res.last)
    all_items += res.items
```

## Drive

### Put

```py
drive.put('hello.txt', 'Hello world')
drive.put(b'hello.txt', 'Hello world')
drive.put('hello.txt', content_type='text/plain')

import io
drive.put('hello.txt', io.StringIO('hello world'))
drive.put('hello.txt', io.BytesIO(b'hello world'))

f = open('./hello.txt', 'r')
drive.put('hello.txt', f)
f.close()

drive.put('hello.txt', path='./hello.txt')
```

### Get

```py
hello = drive.get('hello.txt')
content = hello.read()
hello.close()

# larger files
# iterate chunks of size 4096 and save to disk
large_file = drive.get('large_file.txt')
with open("large_file.txt", "wb+") as f:
    for chunk in large_file.iter_chunks(4096):
        f.write(chunk)
    large_file.close()
```

### Delete Many

```py
result = drive.delete_many(["file1.txt", "file2.txt"])
```

Example output:

```json
{
  "deleted": ["file1.txt", "file2.txt"],
  "failed": {
    "file3.txt": "reason for failure"
  }
}
```

### List

```py
# get all files
result = drive.list()

all_files = result.get("names")
paging = result.get("paging")
last = paging.get("last") if paging else None

while (last):
    # provide last from previous call
    result = drive.list(last=last)

    all_files += result.get("names")
    # update last
    paging = result.get("paging")
    last = paging.get("last") if paging else None

print("all files:", all_files)

res_with_prefix = drive.list(prefix="/blog")
res_with_limit = drive.list(limit=100)
res_with_prefix_limit = drive.list(prefix="/blog", limit=100)
```

Example output

```json
{
  "names": ["file1.txt", "file2.txt"],
  "paging": {
    "size": 2,
    "last": "file2.txt"
  }
}
```

/_ JavaScript _/

## Base

### Put

```js
const Deta = require("deta");

const deta = Deta("project key");
const db = deta.Base("simple_db");

// store objects
// a key will be automatically generated
await db.put({ name: "alex", age: 77 });
// we will use "one" as a key
await db.put({ name: "alex", age: 77 }, "one");
// the key could also be included in the object itself
await db.put({ name: "alex", age: 77, key: "one" });

// store simple types
await db.put("hello, worlds");
await db.put(7);
// "success" is the value and "smart_work" is the key.
await db.put("success", "smart_work");
await db.put(["a", "b", "c"], "my_abc");

// put expiring items
// expire item in 300 seconds
await db.put({ name: "alex", age: 21 }, "alex21", { expireIn: 300 });
// expire item at expire date
await db.put({ name: "max", age: 28 }, "max28", { expireAt: new Date("2023-01-01T00:00:00") });
```

### Insert

```js
// will succeed, a key will be auto-generated
const res1 = await db.insert("hello, world");

// will succeed.
const res2 = await db.insert({ message: "hello, world" }, "greeting1");

// will raise an error as key "greeting1" already existed.
const res3 = await db.insert({ message: "hello, there" }, "greeting1");

// expire item in 300 seconds
await db.insert({ message: "will be deleted" }, "temp_key", { expireIn: 300 });

// expire at date
await db.insert({ message: "will be deleted" }, "temp_key_2", { expireAt: new Date("2023-01-01T00:00:00") });
```

### Put Many

```js
await db.putMany([
  { name: "Beverly", hometown: "Copernicus City", key: "one" }, // key provided
  "dude", // key auto-generated
  ["Namask훮ra", "marhabaan", "hello", "yeoboseyo"], // key auto-generated
]);

// putMany with expire in 300 seconds
await db.putMany(
  [
    { key: "temp-1", name: "test-1" },
    { key: "temp-2", name: "test-2" },
  ],
  { expireIn: 300 },
);

// putMany with expire at
await db.putMany(
  [
    { key: "temp-1", name: "test-1" },
    { key: "temp-2", name: "test-2" },
  ],
  { expireAt: new Date("2023-01-01T00:00:00") },
);
```

Example output:

```json
{
  "processed": {
    "items": [
      {
        "hometown": "Copernicus City",
        "key": "one",
        "name": "Beverly"
      },
      {
        "key": "jyesxxlrezo0",
        "value": "dude"
      },
      {
        "key": "5feqybn7lb05",
        "value": ["Namask훮ra", "hello", "marhabaan", "yeoboseyo"]
      }
    ]
  }
}
```

### Update

Consider we have the following item in a base:

```json
{
  "key": "user-a",
  "username": "jimmy",
  "profile": {
    "age": 32,
    "active": false,
    "hometown": "pittsburgh"
  },
  "on_mobile": true,
  "likes": ["anime"],
  "purchases": 1
}
```

Then the following update operation :

```js
const updates = {
  "profile.age": 33, // set profile.age to 33
  "profile.active": true, // set profile.active to true
  "profile.email": "jimmy@deta.sh", // create a new attribute 'profile.email'
  "profile.hometown": users.util.trim(), // remove 'profile.hometown'
  on_mobile: users.util.trim(), // remove 'on_mobile'
  purchases: users.util.increment(2), // increment 'purchases' by 2, default value is 1
  likes: users.util.append("ramen"), // append 'ramen' to 'likes', also accepts an array
};

const res = await db.update(updates, "user-a");
```

Results in the following item in the base:

```json
{
  "key": "user-a",
  "username": "jimmy",
  "profile": {
    "age": 33,
    "active": true,
    "email": "jimmy@deta.sh"
  },
  "likes": ["anime", "ramen"],
  "purchases": 3
}
```

### Fetch

For the examples, let's assume we have a **Base** with the following data:

```json
[
  {
    "key": "key-1",
    "name": "Wesley",
    "age": 27,
    "hometown": "San Francisco"
  },
  {
    "key": "key-2",
    "name": "Beverly",
    "age": 51,
    "hometown": "Copernicus City"
  },
  {
    "key": "key-3",
    "name": "Kevin Garnett",
    "age": 43,
    "hometown": "Greenville"
  }
]
```

```js
const { items: myFirstSet } = await db.fetch({ "age?lt": 30 });
const { items: mySecondSet } = await db.fetch([{ "age?gt": 50 }, { hometown: "Greenville" }]);
```

... will come back with following data:

`myFirstSet`:

```json
[
  {
    "key": "key-1",
    "name": "Wesley",
    "age": 27,
    "hometown": "San Francisco"
  }
]
```

`mySecondSet`:

```json
[
  {
    "key": "key-2",
    "name": "Beverly",
    "age": 51,
    "hometown": "Copernicus City"
  },
  {
    "key": "key-3",
    "name": "Kevin Garnett",
    "age": 43,
    "hometown": "Greenville"
  }
]
```

#### Fetch All Items

```js
let res = await db.fetch();
let allItems = res.items;

// continue fetching until last is not seen
while (res.last) {
  res = await db.fetch({}, { last: res.last });
  allItems = allItems.concat(res.items);
}
```

## Drive

### Put

```js
drive.put('hello.txt', {data: "Hello world"});
drive.put('hello.txt', {data: "Hello world", contentType: 'text/plain'});

drive.put('hello.txt', {data: Buffer.from('Hello World'), contentType: 'text/plain'});
drive.put('hello.txt', {path: './my/file/path/file.txt'});
drive.put('hello.txt', {path: './my/file/path/file.txt', contentType: 'text/plain'}});
```

### Delete Many

```js
const result = await drive.DeleteMany(["file1.txt", "file2.txt"]);
```

Example output:

```json
{
  "deleted": ["file1.txt", "file2.txt"],
  "failed": {
    "file3.txt": "reason for failure"
  }
}
```

### List

```js
// get all files
let result = await drive.list();
let allFiles = result.names;
let last = result.paging.last;

while (last) {
  // provide last from previous call
  result = await drive.list({ last: result.paging.last });

  allFiles = allFiles.concat(result.names);

  // update last
  last = result.paging.last;
}
console.log("all files:", allFiles);

const resultWithPrefix = await drive.list({ prefix: "blog/" });
const resultWithLimit = await drive.list({ limit: 100 });
const resultWIthLimitAndPrefix = await drive.list({
  limit: 100,
  prefix: "blog/",
});
```

Example output:

```json
{
  "names": ["file1.txt", "file2.txt"],
  "paging": {
    "size": 2,
    "last": "file2.txt"
  }
}
```

/_ Golang _/

## Base

### Instantiate

```go
import (
    "fmt"

    "github.com/deta/deta-go/deta"
    "github.com/deta/deta-go/service/base"
)

func main() {
    // initialize with project key
    // returns ErrBadProjectKey if project key is invalid
    // locally, set the project key in an env var called DETA_PROJECT_KEY
    d, err := deta.New()
    if err != nil {
    fmt.Println("failed to init new Deta instance:", err)
    return
    }

    // initialize with base name
    // returns ErrBadBaseName if base name is invalid
    db, err := base.New(d, "base_name")
    if err != nil {
    fmt.Println("failed to init new Base instance:", err)
    return
    }
}
```

### Put

```go

import (
    "log"
    "time"

    "github.com/deta/deta-go/deta"
    "github.com/deta/deta-go/service/base"
)

type User struct {
    // json struct tag 'key' used to denote the key
    Key      string   `json:"key"`
    Username string   `json:"username"`
    Active   bool     `json:"active"`
    Age      int      `json:"age"`
    Likes    []string `json:"likes"`
    // json struct tag '__expires' for expiration timestamp
    // 'omitempty' for omission of default 0 value
    Expires  int64 `json:"__expires,omitempty"`
}

func main() {
    // errors ignored for brevity
    d, _ := deta.New(deta.WithProjectKey("project_key"))
    db, _ := base.New(d, "users")

    u := &User{
    Key:      "kasdlj1",
    Username: "jimmy",
    Active:   true,
    Age:      20,
    Likes:    []string{"ramen"},
    }
    key, err := db.Put(u)
    if err != nil {
    log.Fatal("failed to put item:", err)
    }
    log.Println("successfully put item with key", key)

    // can also use a map
    um := map[string]interface{}{
    "key":      "kasdlj1",
    "username": "jimmy",
    "active":   true,
    "age":      20,
    "likes":    []string{"ramen"},
    }
    key, err = db.Put(um)
    if err != nil {
    log.Fatal("failed to put item:", err)
    }
    log.Println("Successfully put item with key:", key)

    // put with expires
    u := &User{
    Key: "will_be_deleted",
    Username: "test_user",
    Expires: time.Date(2023, 1, 1, 0, 0, 0, 0, 0, time.UTC).Unix(),
    }
    key, err = db.Put(u)
    if err != nil {
    log.Fatal("failed to put item:", err)
    }
    log.Println("put item with key:", key)

    // put map with expires
    um = map[string]interface{}{
    "key": "will_be_deleted",
    "test": true,
    "__expires": time.Data(2023, 1, 1, 0, 0, 0, 0, time.UTC).Unix(),
    }
    key, err = db.Put(um)
    if err != nil {
    log.Fatal("failed to put item:", err)
    }
    log.Println("put item with key:", key)
}
```

### Get

```go
import (
    "fmt"

    "github.com/deta/deta-go/deta"
    "github.com/deta/deta-go/service/base"
)

type User struct {
    Key      string   `json:"key"` // json struct tag 'key' used to denote the key
    Username string   `json:"username"`
    Active   bool     `json:"active"`
    Age      int      `json:"age"`
    Likes    []string `json:"likes"`
}

func main() {
    d, err := deta.New(deta.WithProjectKey("project_key"))
    if err != nil {
    fmt.Println("failed to init new Deta instance:", err)
    return
    }

    db, err := base.New(d, "users")
    if err != nil {
    fmt.Println("failed to init new Base instance:", err)
    }

    // a variable to store the result
    var u User

    // get item
    // returns ErrNotFound if no item was found
    err = db.Get("kasdlj1", &u)
    if err != nil {
    fmt.Println("failed to get item:", err)
    }
}
```

### Insert

```go
import (
    "fmt"

    "github.com/deta/deta-go/deta"
    "github.com/deta/deta-go/service/base"
)

type User struct {
    Key      string   `json:"key"` // json struct tag 'key' used to denote the key
    Username string   `json:"username"`
    Active   bool     `json:"active"`
    Age      int      `json:"age"`
    Likes    []string `json:"likes"`
}

func main() {
    d, err := deta.New(deta.WithProjectKey("project_key"))
    if err != nil {
    fmt.Println("failed to init new Deta instance:", err)
    return
    }

    db, err := base.New(d, "users")
    if err != nil {
    fmt.Println("failed to init new Base instance:", err)
    }

    u := &User{
    Key:      "kasdlj1",
    Username: "jimmy",
    Active:   true,
    Age:      20,
    Likes:    []string{"ramen"},
    }

    // insert item in the database
    key, err := db.Insert(u)
    if err != nil {
    fmt.Println("failed to insert item:", err)
    return
    }
    fmt.Println("Successfully inserted item with key:", key)
}
```

### Put Many

```go
import (
    "fmt"

    "github.com/deta/deta-go/deta"
    "github.com/deta/deta-go/service/base"
)

type User struct {
    Key      string   `json:"key"` // json struct tag 'key' used to denote the key
    Username string   `json:"username"`
    Active   bool     `json:"active"`
    Age      int      `json:"age"`
    Likes    []string `json:"likes"`
}

func main() {
    d, err := deta.New(deta.WithProjectKey("project_key"))
    if err != nil {
    fmt.Println("failed to init new Deta instance:", err)
    return
    }

    db, err := base.New(d, "users")
    if err != nil {
    fmt.Println("failed to init new Base instance:", err)
    }

    // users
    u1 := &User{
    Key:      "kasdlj1",
    Username: "jimmy",
    Active:   true,
    Age:      20,
    Likes:    []string{"ramen"},
    }
    u2 := &User{
    Key:      "askdjf",
    Username: "joel",
    Active:   true,
    Age:      23,
    Likes:    []string{"coffee"},
    }
    users := []*User{u1, u2}

    // put items in the database
    keys, err := db.PutMany(users)
    if err != nil {
    fmt.Println("failed to put items:", err)
    return
    }
    fmt.Println("Successfully put item with keys:", keys)
}
```

### Update

Consider we have the following item in a base `users`:

```json
{
  "key": "user-a",
  "username": "jimmy",
  "profile": {
    "age": 32,
    "active": false,
    "hometown": "pittsburgh"
  },
  "likes": ["anime"],
  "purchases": 1
}
```

Then the following update operation :

```go
import (
    "fmt"

    "github.com/deta/deta-go/deta"
    "github.com/deta/deta-go/service/base"
)

type Profile struct {
    Active   bool   `json:"active"`
    Age      int    `json:"age"`
    Hometown string `json:"hometown"`
}

type User struct {
    Key       string   `json:"key"` // json struct tag 'key' used to denote the key
    Username  string   `json:"username"`
    Profile   *Profile `json:"profile"`
    Purchases int      `json:"purchases"`
    Likes     []string `json:"likes"`
}

func main() {
    d, err := deta.New(deta.WithProjectKey("project_key"))
    if err != nil {
    fmt.Println("failed to init new Deta instance:", err)
    return
    }

    db, err := base.New(d, "users")
    if err != nil {
    fmt.Println("failed to init new Base instance:", err)
    }

    // define the updates
    updates := base.Updates{
    "profile.age": 33, // set profile.age to 33
    "profile.active": true, // set profile.active to true
    "profile.hometown": db.Util.Trim(), // remove 'profile.hometown'
    "purchases": db.Util.Increment(2), // increment 'purchases' by 2
    "likes": db.Util.Append("ramen"), // append 'ramen' to 'likes', also accepts a slice
    }
    // update
    err = db.Update("user-a", updates)
    if err != nil {
    fmt.Println("failed to update", err)
    return
    }
}
```

Results in the following item in the base:

```json
{
  "key": "user-a",
  "username": "jimmy",
  "profile": {
    "age": 33,
    "active": true
  },
  "likes": ["anime", "ramen"],
  "purchases": 3
}
```

### Fetch

```go
import (
    "fmt"

    "github.com/deta/deta-go/deta"
    "github.com/deta/deta-go/service/base"
)

type User struct {
    Key string `json:"key"`
    Name string `json:"name"`
    Age int `json:"age"`
    Hometown string `json:"hometown"`
}

func main() {
    d, err := deta.New(deta.WithProjectKey("project_key"))
    if err != nil {
    fmt.Println("failed to init new Deta instance:", err)
    return
    }

    db, err := base.New(d, "users")
    if err != nil {
    fmt.Println("failed to init new Base instance:", err)
    }

    // query to get users with age less than 30
    query := base.Query{
    {"age?lt": 50},
    }

    // variabe to store the results
    var results []*User

    // fetch items
    _, err = db.Fetch(&base.FetchInput{
    Q:    query,
    Dest: &results,
    })
    if err != nil {
    fmt.Println("failed to fetch items:", err)
    }
}
```

... `results` will have the following data:

```json
[
  {
    "key": "key-1",
    "name": "Wesley",
    "age": 27,
    "hometown": "San Francisco"
  },
  {
    "key": "key-3",
    "name": "Kevin Garnett",
    "age": 43,
    "hometown": "Greenville"
  }
]
```

#### Paginated example

```go
import (
    "fmt"

    "github.com/deta/deta-go/deta"
    "github.com/deta/deta-go/service/base"
)

type User struct {
    Key      string   `json:"key"` // json struct tag 'key' used to denote the key
    Username string   `json:"username"`
    Active   bool     `json:"active"`
    Age      int      `json:"age"`
    Likes    []string `json:"likes"`
}

func main() {
    d, err := deta.New(deta.WithProjectKey("project_key"))
    if err != nil {
    fmt.Println("failed to init new Deta instance:", err)
    return
    }

    db, err := base.New(d, "users")
    if err != nil {
    fmt.Println("failed to init new Base instance:", err)
    }

    // query to get users with age less than 30
    query := base.Query{
    {"age?lt": 50},
    }

    // variabe to store the results
    var results []*User

    // variable to store the page
    var page []*User

    // fetch input
    i := &base.FetchInput{
    Q:     query,
    Dest:  &page,
    Limit: 1, // limit provided so each page will only have one item
    }

    // fetch items
    lastKey, err := db.Fetch(i)
    if err != nil {
    fmt.Println("failed to fetch items:", err)
    return
    }

    // append page items to results
    results = append(results, page...)

    // get all pages
    for lastKey != "" {
    // provide the last key in the fetch input
    i.LastKey = lastKey

    // fetch
    lastKey, err = db.Fetch(i)
    if err != nil {
        fmt.Println("failed to fetch items:", err)
        return
    }

    // append page items to all results
    results = append(results, page...)
    }
}
```

## Drive

### Instantiate

```go
import (
    "fmt"

    "github.com/deta/deta-go/deta"
    "github.com/deta/deta-go/service/drive"
)

func main() {

    // initialize with project key
    // returns ErrBadProjectKey if project key is invalid
    d, err := deta.New(deta.WithProjectKey("project_key"))
    if err != nil {
        fmt.Println("failed to init new Deta instance:", err)
        return
    }

    // initialize with drive name
    // returns ErrBadDriveName if base name is invalid
    drive, err := drive.New(d, "drive_name")
    if err != nil {
        fmt.Println("failed to init new Drive instance:", err)
        return
    }
}
```

### Put

```go
import (
    "bufio"
    "fmt"
    "os"

    "github.com/deta/deta-go/deta"
    "github.com/deta/deta-go/service/drive"
)

func main() {
    // initialize with project key
    // returns ErrBadProjectKey if project key is invalid
    d, err := deta.New(deta.WithProjectKey("project_key"))
    if err != nil {
        fmt.Println("failed to init new Deta instance:", err)
        return
    }

    // initialize with drive name
    // returns ErrBadDriveName if drive name is invalid
    drawings, err := drive.New(d, "drawings")
    if err != nil {
        fmt.Println("failed to init new Drive instance:", err)
        return
    }
    // PUT
    // reading from a local file
    file, err := os.Open("./art.svg")
    defer file.Close()

    name, err := drawings.Put(&drive.PutInput{
        Name:        "art.svg",
        Body:        bufio.NewReader(file),
        ContentType: "image/svg+xml",
    })
    if err != nil {
        fmt.Println("failed to put file:", err)
        return
    }
    fmt.Println("Successfully put file with name:", name)
}
```

### Get

```go
import (
    "fmt"
    "io/ioutil"

    "github.com/deta/deta-go/deta"
    "github.com/deta/deta-go/service/drive"
)

func main() {

    // initialize with project key
    // returns ErrBadProjectKey if project key is invalid
    d, err := deta.New(deta.WithProjectKey("project_key"))
    if err != nil {
        fmt.Println("failed to init new Deta instance:", err)
        return
    }

    // initialize with drive name
    // returns ErrBadDriveName if drive name is invalid
    drawings, err := drive.New(d, "drawings")
    if err != nil {
        fmt.Println("failed to init new Drive instance:", err)
        return
    }

    // GET
    name := "art.svg"
    f, err := drawings.Get(name)
    if err != nil {
        fmt.Println("failed to get file with name:", name)
        return
    }
    defer f.Close()

    c, err := ioutil.ReadAll(f)
    if err != nil {
        fmt.Println("failed read file content with err:", err)
        return
    }
    fmt.Println("file content:", string(c))
}
```

### Delete

```go
import (
    "fmt"

    "github.com/deta/deta-go/deta"
    "github.com/deta/deta-go/service/drive"
)

func main() {

    // initialize with project key
    // returns ErrBadProjectKey if project key is invalid
    d, err := deta.New(deta.WithProjectKey("project_key"))
    if err != nil {
        fmt.Println("failed to init new Deta instance:", err)
        return
    }

    // initialize with drive name
    // returns ErrBadDriveName if drive name is invalid
    drawings, err := drive.New(d, "drawings")
    if err != nil {
        fmt.Println("failed to init new Drive instance:", err)
        return
    }

    // DELETE
    name, err := drawings.Delete("art.svg")
    if err != nil {
        fmt.Println("failed to delete file with name:", name)
        return
    }
    fmt.Println("Successfully deleted file with name:", name)
}
```

### Delete Many

```go
import (
    "fmt"

    "github.com/deta/deta-go/deta"
    "github.com/deta/deta-go/service/drive"
)

func main() {
    // initialize with project key
    // returns ErrBadProjectKey if project key is invalid
    d, err := deta.New(deta.WithProjectKey("project_key"))
    if err != nil {
        fmt.Println("failed to init new Deta instance:", err)
        return
    }

    // initialize with drive name
    // returns ErrBadDriveName if drive name is invalid
    drawings, err := drive.New(d, "drawings")
    if err != nil {
        fmt.Println("failed to init new Drive instance:", err)
        return
    }

    names := []string{"a", "b", "c"}
    dr, err := drawings.DeleteMany(names)

    if err != nil {
        fmt.Println("failed to delete files")
        return
    }
    fmt.Println("deleted:", dr.Deleted)
    fmt.Println("failed:", dr.Failed)
}
```

### List

```go
import (
    "fmt"

    "github.com/deta/deta-go/deta"
    "github.com/deta/deta-go/service/drive"
)

func main() {

    // initialize with project key
    // returns ErrBadProjectKey if project key is invalid
    d, err := deta.New(deta.WithProjectKey("project_key"))
    if err != nil {
        fmt.Println("failed to init new Deta instance:", err)
        return
    }

    // initialize with drive name
    // returns ErrBadDriveName if drive name is invalid
    drawings, err := drive.New(d, "drawings")
    if err != nil {
        fmt.Println("failed to init new Drive instance:", err)
        return
    }

    lr, err := drawings.List(1000, "", "")
    if err != nil {
        fmt.Println("failed to list names from drive with err:", err)
    }
    // ["a", "b", "c/d"]
    fmt.Println("names:", lr.Names)

    lr, err = drawings.List(1, "", "")
    if err != nil {
        fmt.Println("failed to list names from drive with err:", err)
    }
    // ["a"]
    fmt.Println("names:", lr.Names)


    lr, err = drawings.List(2, "", "")
    if err != nil {
        fmt.Println("failed to list names from drive with err:", err)
    }
    // "b"
    fmt.Println("last:", *lr.Paging.Last)
}
```
